= Understanding Orchestration Using Mule
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: anypoint studio, studio, mule esb, orchestration

Orchestration is a process by which Mule apps facilitate the movement of data
through processors within Mule flows. Orchestration can be understood as
a combination of service calls that work together to create higher-level,
more useful, composite services that implement business-level processes. These
processes combine business-specific services across applications and
information systems.

== Orchestration and Flows

Orchestration involves the replacement of point-to-point integrations with chains
of messages sent to sources that can be reused or changed as systems or business
needs change. Orchestration moves beyond patterns to a service-based framework,
where you wrap multiple components with sources to decouple them from protocols
and routing requirements. This framework enables multiple services to work as
one when implementation requirements demand it.

Common use cases that Mule flows can easily orchestrate include the following:

* Simple integrations
* Scheduled data processing
* Connections between Cloud and on-premise apps
* Event processing where multiple services must be composed and operate
simultaneously

== How Flows Enable the Implementation of Orchestration

Flows enable you to orchestrate service mediation. For example, you can combine
an arbitrary number of message sources, routers, and components to work in
concert to achieve implementation requirements. Flows enable you to move data
based on flow-specific routers. Orchestration enables you to create and reuse
subflows, chain together multiple components in one flow, and integrate sources
or connectors anywhere in a flow.

== When to Use Orchestration

You use orchestration when business needs require you to combine existing
services that reside on different systems. For example, you might use
orchestration when you are adding a new employee to the payroll and HR systems.
You might use orchestration for a workflow that accepts an order, makes sure
the order is in the inventory system, uses the credit check system to ensure
you trust the customer's credit, put the order to the billing system, and
finally, submit the order in the shipping system.

== An Example of Orchestration

The following orchestration example uses a Mule flow to receive a book order in
an XML file and transform that fileâ€™s contents into a standard format that
contains one or more orders. To process the orders individually, the flow then
splits them into a collection and filters out any non-book orders, retaining
only the book orders so that it can call the appropriate services for them:

* One service checks for the book in the company's inventory system.
* The other service creates a customer order.

After successfully calling the services, the flow emails the customer about the
order and stores the order into a database. If anything in this process fails,
the message is placed in a JMS queue of failed orders, where it can be checked,
any error fixed, and finally resubmitted.

[source,xml,linenums]
----
<flow name="orderHandling">
  <file:listener directory="/myDirectory">
    <scheduling-strategy>
      <fixed-frequency/>
    </scheduling-strategy>
    <file:matcher filenamePattern="*.xml"/>
  </file:listener>
  <ee:transform>
    <ee:message>
      <ee:set-payload resource="createBookOrdersTransformation.dwl"/>
    </ee:message>
  </ee:transform>
  <foreach collection="#[payload.orders]">
    <choice>
      <when expression="#[payload.order.'type' == 'book']">
        <http:request method="POST" path="/book/inventory"/>
        <http:request method="POST" path="/book/order"/>
        <email:send toAddresses="#[payload.customer.email]">
          <email:body >
            <email:content ><![CDATA[#['Your order has been placed.']]]></email:content>
          </email:body>
        </email:send>
        <db:insert>
          <db:sql >INSERT INTO ORDERS(CUSTOMER, AMOUNT) VALUES (:id, :amount)</db:sql>
          <db:input-parameters><![CDATA[#[{ id : payload.customer.id, amount: payload.order.total }]]]></db:input-parameters>
        </db:insert>
      </when>
    </choice>
  </foreach>
  <error-handler >
    <on-error-continue>
      <jms:publish destination="failedOrders"/>
    </on-error-continue>
  </error-handler>
</flow>
----
